
# 목차
- [펫네트워크(Pet-Netwrok) 개요](#펫네트워크pet-netwrok-개요)
- [개발](#개발)
- [기능소개](#기능소개)
- [Back-End 개발](#back-end-개발)
- [트러블슈팅](#트러블슈팅)
- [전체적인 성과 및 피드백](#전체적인-성과-및-피드백)
- [아키텍처 구조](#아키텍처-구조)
- [ERD](#erd)

<br><br><br>


# 펫네트워크(Pet-Netwrok) 개요
![image](https://github.com/user-attachments/assets/fd792e67-41ae-45bd-9b8c-83a0bb7be8d1)
펫네트워크(PET-NETWORK)는 분산되어 있던 반려동물 쇼핑몰, 가계부, 커뮤니티, 동반 지도, 포인트 상점 등 다수의 서비스를 하나로 통합하여 사용자가 더욱 편리하고 폭넓은 경험을 누릴 수 있도록 기획된 올인원 플랫폼입니다. 
기존에 쇼핑몰은 쇼핑몰대로, 커뮤니티는 커뮤니티대로 따로 접근해야 했던 번거로움을 해소하고, 지출 내역 역시 쇼핑 정보를 기반으로 자동 기록함으로써 반려동물을 위한 소비 패턴을 체계적으로 관리할 수 있게 하였습니다. 또한 정보 공유에 적극적인 반려인들이 커뮤니티를 통해 자유롭게 의견을 주고받고, 동반 지도 기능으로 반려동물과 함께 갈 수 있는 장소를 간편하게 확인하도록 지원합니다. 나아가 플랫폼 내 활동을 통해 적립한 포인트로 편의점상품을 구매할 수 있도록 하여 유저의 참여도를 높이는 동시에 혜택을 제공하는 선순환 구조를 구축하고자 하였습니다. 

<br><br><br>


## 개발
![JAVA](https://img.shields.io/badge/JAVA-%23ED8B00.svg?style=for-the-badge&logo=java&logoColor=white)
![SpringBoot](https://img.shields.io/badge/SpringBoot-%236DB33F.svg?style=for-the-badge&logo=springboot&logoColor=white)
![Gradle](https://img.shields.io/badge/Gradle-%2302303A.svg?style=for-the-badge&logo=gradle&logoColor=white)
![MySQL](https://img.shields.io/badge/MySQL-%234479A1.svg?style=for-the-badge&logo=mysql&logoColor=white)
![myBatis](https://img.shields.io/badge/myBatis-%232571E5.svg?style=for-the-badge)
![Spring Security](https://img.shields.io/badge/Spring%20Security-%236DB33F.svg?style=for-the-badge&logo=springsecurity&logoColor=white)
![Lombok](https://img.shields.io/badge/Lombok-%23E67E22.svg?style=for-the-badge&logo=lombok&logoColor=white)
![Log4J](https://img.shields.io/badge/Log4J-%23F16529.svg?style=for-the-badge)
![React](https://img.shields.io/badge/React-%2361DAFB.svg?style=for-the-badge&logo=react&logoColor=white)
![Vite](https://img.shields.io/badge/Vite-%23646CFF.svg?style=for-the-badge&logo=vite&logoColor=white)
![React-Bootstrap](https://img.shields.io/badge/React--Bootstrap-%23563D7C.svg?style=for-the-badge)
![CSS3](https://img.shields.io/badge/CSS3-%231572B6.svg?style=for-the-badge&logo=css3&logoColor=white)
![JavaScript](https://img.shields.io/badge/JavaScript-%23F7DF1E.svg?style=for-the-badge&logo=javascript&logoColor=black)
![Axios](https://img.shields.io/badge/Axios-%23007ACC.svg?style=for-the-badge)
![MUI](https://img.shields.io/badge/MUI-%230081CB.svg?style=for-the-badge&logo=mui&logoColor=white)
![Ant Design](https://img.shields.io/badge/Ant%20Design-%230170FE.svg?style=for-the-badge)
![Toastify](https://img.shields.io/badge/Toastify-%23F37726.svg?style=for-the-badge)
![FontAwesome](https://img.shields.io/badge/Font%20Awesome-%23339AF0.svg?style=for-the-badge&logo=fontawesome&logoColor=white)
![FullCalendar](https://img.shields.io/badge/FullCalendar-%236DC4F2.svg?style=for-the-badge)
![Quill](https://img.shields.io/badge/Quill-%23D1D3D4.svg?style=for-the-badge)
![Chart.js](https://img.shields.io/badge/Chart.js-%23FF6384.svg?style=for-the-badge&logo=chartdotjs&logoColor=white)
![ZXing](https://img.shields.io/badge/ZXing-%232E7D32.svg?style=for-the-badge)

## CI / CD
![GitHub](https://img.shields.io/badge/GitHub-%23181717.svg?style=for-the-badge&logo=github&logoColor=white)
![AWS](https://img.shields.io/badge/AWS-%23FF9900.svg?style=for-the-badge&logo=amazonaws&logoColor=white)
![EC2](https://img.shields.io/badge/EC2-%23FF9900.svg?style=for-the-badge&logo=amazonaws&logoColor=white)
![Nginx](https://img.shields.io/badge/Nginx-%23009639.svg?style=for-the-badge&logo=nginx&logoColor=white)
![Docker](https://img.shields.io/badge/Docker-%232496ED.svg?style=for-the-badge&logo=docker&logoColor=white)
![Docker Compose](https://img.shields.io/badge/Docker%20Compose-%232496ED.svg?style=for-the-badge&logo=docker&logoColor=white)

## API
- 다음(카카오) 주소 API
- Portone API
- Google Maps JavaScript API
- Google Places API
- Google Geocoding API

## 테스트 및 도구
![JUnit](https://img.shields.io/badge/JUnit5-%2318B439.svg?style=for-the-badge)
![Postman](https://img.shields.io/badge/Postman-%23FF6C37.svg?style=for-the-badge&logo=postman&logoColor=white)
![Chrome DevTools](https://img.shields.io/badge/Chrome%20DevTools-%234285F4.svg?style=for-the-badge&logo=googlechrome&logoColor=white)
- StarUML
- ERDCloud
- MobaXterm


<br><br><br>


# 기능소개
![image](https://github.com/user-attachments/assets/b4d4fd45-3799-446b-bef0-4b29a0e004cc)
<br>
![image](https://github.com/user-attachments/assets/d034e421-5da6-4551-a5ba-2a6567dab3ec)
<br>
![image](https://github.com/user-attachments/assets/e2942d19-4be9-45aa-9005-e759b1b3d753)
<br>
![image](https://github.com/user-attachments/assets/6d634416-3a88-4f7a-8648-f4004028c337)
<br>
![image](https://github.com/user-attachments/assets/665d4aa6-6799-45f7-98ef-28a2083a4c44)
<br>
![image](https://github.com/user-attachments/assets/bd2a87f3-5be2-49a4-a4cc-9d86974f1ebc)
<br>
![image](https://github.com/user-attachments/assets/b5ec1eaf-c5a0-4955-ae53-d8d6ef54af62)


<br><br><br>


# Back-End 개발
Back-End 요청/응답 흐름
기본적인 Back-End 요청/응답의 흐름은 Controller - Service - Mapper 로 이어지는 구조입니다.
![image](https://github.com/user-attachments/assets/b15b8826-1b4a-428e-9158-13044971bb03)


더 자세한 흐름은,

1.User <-> React  
사용자가 React 프론트엔드에서 특정 작업(예: 버튼 클릭, 데이터 요청 등)을 수행합니다.
React는 Axios나 Fetch API 등을 사용하여 백엔드로 HTTP 요청을 보냅니다.

2.React <-> RestController  
React에서 보낸 HTTP 요청은 백엔드의 RestController로 전달됩니다.
예를 들어, /api/cashbook/expense 경로에 대해 요청이 오면 해당 컨트롤러의 메서드가 실행됩니다.
요청 데이터를 기반으로 적절한 작업을 수행할 수 있도록 Service 계층에 위임합니다.

3.RestController <-> Service  
RestController는 비즈니스 로직 처리를 위해 Service를 호출합니다.
이 단계에서는 데이터를 가공하거나 요청의 유효성을 검사합니다.
Service는 세부 로직 처리를 위해 ServiceImpl로 작업을 위임합니다.

4.Service <-> ServiceImpl  
Service는 인터페이스 역할을 하며, 구체적인 비즈니스 로직은 ServiceImpl에서 처리됩니다.
데이터베이스 작업이 필요하면 Mapper를 호출합니다.

5.ServiceImpl <-> Mapper  
ServiceImpl은 Mapper(Java 인터페이스)를 호출하여 SQL 쿼리를 실행합니다.
MyBatis가 Mapper(Java 인터페이스)와 Mapper(XML)를 연결하여 실제 SQL 쿼리를 실행합니다.

6.Mapper <-> DB  
Mapper(XML)에 작성된 SQL이 실행되어 데이터베이스와 통신합니다.
데이터베이스에서 데이터를 조회하거나 삽입/수정/삭제 작업을 수행합니다.
DB에서 반환된 결과는 Mapper를 통해 ServiceImpl로 전달됩니다.

7.ServiceImpl -> Service -> RestController  
ServiceImpl에서 처리된 결과가 Service를 거쳐 RestController로 반환됩니다.
이 과정에서 비즈니스 로직이 완료되고, 사용자 요청에 맞는 응답 데이터가 준비됩니다.

8.RestController -> React  
RestController는 준비된 데이터를 JSON 형식으로 React에 반환합니다.
예를 들어, 조회된 데이터 리스트나 작업 성공 여부를 응답합니다.

9.React -> User  
React는 백엔드에서 전달받은 데이터를 화면에 렌더링합니다.
사용자는 화면을 통해 데이터를 확인하거나 결과를 확인합니다.


<br><br><br>


# 트러블슈팅

## 1. UI 상태 관리
- **이슈**:
  - 슬라이드 패널, 드롭다운 등 여러 UI 컴포넌트 간 상태를 개별적으로 관리하면서 데이터 전달 및 동기화가 복잡해짐.
  - 상위 컴포넌트에서 상태를 관리하고 하위 컴포넌트로 전달하다 보니 **props drilling**이 발생.
- **해결**:
  - React의 **Context API**를 사용하여 상태를 전역에서 관리하고 필요한 컴포넌트에서 접근 가능하도록 구현.
  - **예**: `UserContext`를 통해 사용자 ID를 전역으로 관리하여 props 전달 없이 상태 접근.
- **성과**:
  - 상태 전달 과정이 단순화되어 코드 가독성 및 유지보수성 향상.
  - Context API를 사용함으로써 상태 변경 및 동기화가 원활히 이루어짐.

<br>

## 2. 데이터 시각화 (Chart.js와 Progress Bar)
- **이슈**:
  - React 상태와 시각화 데이터 간 동기화가 맞지 않아 그래프 및 Progress Bar가 즉시 업데이트되지 않음.
- **해결**:
  - 상태 변경 시 데이터 재가공 로직을 `useEffect`에 추가하여 Chart.js의 `datasets`를 업데이트.
  - Bootstrap Progress Bar의 상태를 `usedAmount`와 `budgetAmount` 값으로 동적으로 렌더링.
  - 예산 초기화 시, 상태를 초기화(`setBudgets`)하고 UI에 즉시 반영되도록 데이터 재로딩 로직 추가.
- **성과**:
  - 데이터 변경 사항이 시각화 컴포넌트에 실시간으로 반영됨.
  - 사용자 경험 및 UI 신뢰성 개선.

<br>

## 3. 검색 최적화
- **이슈**:
  - 다중 검색 조건(날짜, 동물/지출 카테고리, 결제 수단 등)이 추가되면서 SQL 성능 저하 발생.
- **해결**:
  - MyBatis의 `<if>` 문법을 사용하여 조건에 맞는 SQL만 동적으로 생성.
  - **예**: 날짜 범위, 카테고리 조건이 없을 경우 해당 필드는 쿼리에서 제외.
  - 프론트엔드에서 조건을 JSON 형식으로 전달하고, 서버에서 필요한 조건만 처리.
- **성과**:
  - SQL 처리 속도 향상 및 불필요한 데이터 전송량 감소.
  - 중복 조건 검색 구현을 통해 사용자 맞춤형 검색 제공.

<br>

## 4. 무한 스크롤 (Infinite Scroll)
- **이슈**:
  - 클라이언트에서 중복 데이터가 로드되는 문제가 발생.
  - 데이터 페이징 처리 및 중복 검사 로직이 필요.
- **해결**:
  - 클라이언트에서 기존 데이터와 새로 로드된 데이터를 비교(`expenseId`)하여 중복을 제거.
  - SQL에서 `LIMIT`와 `OFFSET`을 사용해 페이징 처리.
  - 정렬 옵션(최신순, 과거순)을 추가하여 사용자 선택에 따라 데이터를 로드.
- **성과**:
  - 중복 데이터 문제 해결 및 무한 스크롤 UX 개선.
  - 페이징 처리와 클라이언트 필터링으로 서버 부하 감소.

<br>

## 5. 예산 데이터 초기화
- **이슈**:
  - 예산 데이터를 초기화한 후 UI에 변경 사항이 즉시 반영되지 않음.
- **해결**:
  - 초기화 요청 후 상태(`usedAmount`)를 직접 업데이트하고, 서버에서 데이터를 다시 로드하는 로직 추가.
  - 예산 초기화 시 Toast 메시지를 표시하여 사용자에게 작업 결과를 명확히 전달.
- **성과**:
  - 데이터 동기화 문제 해결.
  - 사용자 경험 및 UI 피드백 개선.

<br>

# 전체적인 성과 및 피드백

## 성과
1. **주요 기능 구현 완료**:
   - 지출 등록, 검색, 무한 스크롤, 통계 대시보드, 예산 관리 등 가계부의 핵심 기능 완성.
2. **UI/UX 개선**:
   - 상태 관리 및 시각화 컴포넌트 개선으로 사용성이 향상됨.
3. **효율적인 데이터 처리**:
   - MyBatis의 동적 쿼리와 SQL 최적화를 통해 성능을 개선.
   - 무한 스크롤과 페이징 처리로 서버 부하 감소.
4. **협업 경험**:
   - 팀원과의 코드 리뷰 및 연계 작업을 통해 협업 능력을 강화.

<br>

## 피드백
1. **상태 관리**:
   - Context API는 효율적이지만, 프로젝트가 확장되면 상태 관리 라이브러리 사용을 검토할 필요 있음.
2. **쿼리 최적화**:
   - 검색 쿼리 및 페이징 처리 시 데이터베이스 인덱싱 활용을 정기적으로 점검.
3. **코드 구조 개선**:
   - 공통으로 사용하는 컴포넌트와 유틸리티 함수를 별도 파일로 분리하여 재사용성을 높이는 방안을 모색.



<br><br><br>
# ERD
![image](https://github.com/user-attachments/assets/2a38a0b0-4ba6-4655-a79d-912a60c7e056)

<br><br><br>

# 아키텍처 구조
![image](https://github.com/user-attachments/assets/e64aa413-80d6-4e52-9f14-d208c779e437)  
펫 네트워크 서비스의 클라우드 서버 구조에 대해서 설명 드리겠습니다.
먼저 1개의 VPC 안에 2개의 가용영역을 만들었습니다.
이로써 한 쪽이 정상적으로 동작하지 않으면, 다른 한쪽이 동작하는 안정성을 고려하였습니다.
WEB서버는 퍼블릭 서브넷에 두고, 비즈니스 로직이 들어있는 WAS와 DB는 프라이빗 서브넷에 두었습니다.
각 프라이빗 서브넷에 접근하기 위하여 퍼블릭 서브넷에는 NAT게이트웨이를 설치하여 Bastion서버 역할을 겸하도록 했습니다.
이후 도메인을 Route53에 등록하고, HTTPS접속을 위하여 ACM을 발급받아서 도메인으로 펫 네트워크 서비스에 접속할 수 있도록 구성했습니다.


<br><br><br>









